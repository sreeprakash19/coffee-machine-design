{"version":3,"file":"common.js","sourceRoot":"","sources":["../../../src/compile/common.ts"],"names":[],"mappings":"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","sourcesContent":["import {Text} from 'vega';\nimport {array} from 'vega-util';\nimport {isBinning} from '../bin';\nimport {\n  FieldDefBase,\n  FieldRefOption,\n  isScaleFieldDef,\n  isTimeFormatFieldDef,\n  OrderFieldDef,\n  TypedFieldDef,\n  vgField\n} from '../channeldef';\nimport {Config, StyleConfigIndex} from '../config';\nimport {MarkConfig, MarkDef} from '../mark';\nimport {fieldValidPredicate} from '../predicate';\nimport {ScaleType} from '../scale';\nimport {SortFields} from '../sort';\nimport {formatExpression, TimeUnit} from '../timeunit';\nimport {isText} from '../title';\nimport {QUANTITATIVE} from '../type';\nimport {getFirstDefined} from '../util';\nimport {BaseMarkConfig, VgEncodeEntry} from '../vega.schema';\nimport {deepEqual} from './../util';\nimport {AxisComponentProps} from './axis/component';\nimport {Explicit} from './split';\nimport {UnitModel} from './unit';\n\nexport const BIN_RANGE_DELIMITER = ' \\u2013 ';\n\nexport function applyMarkConfig(e: VgEncodeEntry, model: UnitModel, propsList: (keyof MarkConfig)[]) {\n  for (const property of propsList) {\n    const value = getMarkConfig(property, model.markDef, model.config);\n    if (value !== undefined) {\n      e[property] = {value: value};\n    }\n  }\n  return e;\n}\n\nexport function getStyles(mark: MarkDef): string[] {\n  return [].concat(mark.type, mark.style ?? []);\n}\n\nexport function getMarkPropOrConfig<P extends keyof MarkConfig>(channel: P, mark: MarkDef, config: Config) {\n  return getFirstDefined(mark[channel], getMarkConfig(channel, mark, config));\n}\n\n/**\n * Return property value from style or mark specific config property if exists.\n * Otherwise, return general mark specific config.\n */\nexport function getMarkConfig<P extends keyof MarkConfig>(\n  channel: P,\n  mark: MarkDef,\n  config: Config,\n  {vgChannel}: {vgChannel?: any} = {} // Note: Ham: I use `any` here as it's too hard to make TS knows that MarkConfig[vgChannel] would have the same type as MarkConfig[P]\n): MarkConfig[P] {\n  return getFirstDefined(\n    // style config has highest precedence\n    vgChannel ? getStyleConfig(channel, mark, config.style) : undefined,\n    getStyleConfig(channel, mark, config.style),\n    // then mark-specific config\n    vgChannel ? config[mark.type][vgChannel] : undefined,\n    config[mark.type][channel],\n    // If there is vgChannel, skip vl channel.\n    // For example, vl size for text is vg fontSize, but config.mark.size is only for point size.\n    vgChannel ? config.mark[vgChannel] : config.mark[channel]\n  );\n}\n\nexport function getStyleConfig<P extends keyof MarkConfig>(prop: P, mark: MarkDef, styleConfigIndex: StyleConfigIndex) {\n  const styles = getStyles(mark);\n  let value;\n  for (const style of styles) {\n    const styleConfig = styleConfigIndex[style];\n\n    // MarkConfig extends VgMarkConfig so a prop may not be a valid property for style\n    // However here we also check if it is defined, so it is okay to cast here\n    const p = prop as keyof BaseMarkConfig;\n    if (styleConfig && styleConfig[p] !== undefined) {\n      value = styleConfig[p];\n    }\n  }\n  return value;\n}\n\nexport function formatSignalRef(\n  fieldDef: TypedFieldDef<string>,\n  specifiedFormat: string,\n  expr: 'datum' | 'parent' | 'datum.datum',\n  config: Config\n) {\n  if (isTimeFormatFieldDef(fieldDef)) {\n    const isUTCScale = isScaleFieldDef(fieldDef) && fieldDef['scale'] && fieldDef['scale'].type === ScaleType.UTC;\n    return {\n      signal: timeFormatExpression(\n        vgField(fieldDef, {\n          expr\n        }),\n        fieldDef.timeUnit,\n        specifiedFormat,\n        config.timeFormat,\n        isUTCScale,\n        true\n      )\n    };\n  } else {\n    const format = numberFormat(fieldDef, specifiedFormat, config);\n    if (isBinning(fieldDef.bin)) {\n      const startField = vgField(fieldDef, {expr});\n      const endField = vgField(fieldDef, {expr, binSuffix: 'end'});\n      return {\n        signal: binFormatExpression(startField, endField, format, config)\n      };\n    } else if (fieldDef.type === 'quantitative' || format) {\n      return {\n        signal: `${formatExpr(vgField(fieldDef, {expr, binSuffix: 'range'}), format)}`\n      };\n    } else {\n      return {signal: `''+${vgField(fieldDef, {expr})}`};\n    }\n  }\n}\n\n/**\n * Returns number format for a fieldDef\n */\nexport function numberFormat(fieldDef: TypedFieldDef<string>, specifiedFormat: string, config: Config) {\n  // Specified format in axis/legend has higher precedence than fieldDef.format\n  if (specifiedFormat) {\n    return specifiedFormat;\n  }\n\n  if (fieldDef.type === QUANTITATIVE) {\n    // we only apply the default if the field is quantitative\n    return config.numberFormat;\n  }\n  return undefined;\n}\n\nfunction formatExpr(field: string, format: string) {\n  return `format(${field}, \"${format || ''}\")`;\n}\n\nexport function numberFormatExpr(field: string, specifiedFormat: string, config: Config) {\n  return formatExpr(field, specifiedFormat ?? config.numberFormat);\n}\n\nexport function binFormatExpression(startField: string, endField: string, format: string, config: Config) {\n  return `${fieldValidPredicate(startField, false)} ? \"null\" : ${numberFormatExpr(\n    startField,\n    format,\n    config\n  )} + \"${BIN_RANGE_DELIMITER}\" + ${numberFormatExpr(endField, format, config)}`;\n}\n\n/**\n * Returns the time expression used for axis/legend labels or text mark for a temporal field\n */\nexport function timeFormatExpression(\n  field: string,\n  timeUnit: TimeUnit,\n  format: string,\n  rawTimeFormat: string, // should be provided only for actual text and headers, not axis/legend labels\n  isUTCScale: boolean,\n  alwaysReturn = false\n): string {\n  if (!timeUnit || format) {\n    // If there is not time unit, or if user explicitly specify format for axis/legend/text.\n    format = format ?? rawTimeFormat; // only use provided timeFormat if there is no timeUnit.\n    if (format || alwaysReturn) {\n      return `${isUTCScale ? 'utc' : 'time'}Format(${field}, '${format}')`;\n    } else {\n      return undefined;\n    }\n  } else {\n    return formatExpression(timeUnit, field, isUTCScale);\n  }\n}\n\n/**\n * Return Vega sort parameters (tuple of field and order).\n */\nexport function sortParams(\n  orderDef: OrderFieldDef<string> | OrderFieldDef<string>[],\n  fieldRefOption?: FieldRefOption\n): SortFields {\n  return array(orderDef).reduce(\n    (s, orderChannelDef) => {\n      s.field.push(vgField(orderChannelDef, fieldRefOption));\n      s.order.push(orderChannelDef.sort ?? 'ascending');\n      return s;\n    },\n    {field: [], order: []}\n  );\n}\n\nexport type AxisTitleComponent = AxisComponentProps['title'];\n\nexport function mergeTitleFieldDefs(f1: readonly FieldDefBase<string>[], f2: readonly FieldDefBase<string>[]) {\n  const merged = [...f1];\n\n  f2.forEach(fdToMerge => {\n    for (const fieldDef1 of merged) {\n      // If already exists, no need to append to merged array\n      if (deepEqual(fieldDef1, fdToMerge)) {\n        return;\n      }\n    }\n    merged.push(fdToMerge);\n  });\n  return merged;\n}\n\nexport function mergeTitle(title1: Text, title2: Text) {\n  if (deepEqual(title1, title2) || !title2) {\n    // if titles are the same or title2 is falsy\n    return title1;\n  } else if (!title1) {\n    // if title1 is falsy\n    return title2;\n  } else {\n    return [...array(title1), ...array(title2)].join(', ');\n  }\n}\n\nexport function mergeTitleComponent(v1: Explicit<AxisTitleComponent>, v2: Explicit<AxisTitleComponent>) {\n  const v1Val = v1.value;\n  const v2Val = v2.value;\n\n  if (v1Val == null || v2Val === null) {\n    return {\n      explicit: v1.explicit,\n      value: null\n    };\n  } else if (isText(v1Val) && isText(v2Val)) {\n    return {\n      explicit: v1.explicit,\n      value: mergeTitle(v1Val, v2Val)\n    };\n  } else if (!isText(v1Val) && !isText(v2Val)) {\n    return {\n      explicit: v1.explicit,\n      value: mergeTitleFieldDefs(v1Val, v2Val)\n    };\n  }\n  /* istanbul ignore next: Condition should not happen -- only for warning in development. */\n  throw new Error('It should never reach here');\n}\n"]}