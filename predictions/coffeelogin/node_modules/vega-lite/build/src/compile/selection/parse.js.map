{"version":3,"file":"parse.js","sourceRoot":"","sources":["../../../../src/compile/selection/parse.ts"],"names":[],"mappings":"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","sourcesContent":["import {selector as parseSelector} from 'vega-event-selector';\nimport {hasOwnProperty, isString, stringValue} from 'vega-util';\nimport {SelectionComponent, STORE, forEachSelection} from '.';\nimport {LogicalOperand} from '../../logical';\nimport {SelectionDef, SelectionExtent} from '../../selection';\nimport {Dict, duplicate, logicalExpr, varName} from '../../util';\nimport {DataFlowNode, OutputNode} from '../data/dataflow';\nimport {Model} from '../model';\nimport {UnitModel} from '../unit';\nimport {forEachTransform} from './transforms/transforms';\nimport {warn} from '../../log';\nimport {FilterNode} from '../data/filter';\n\nexport function parseUnitSelection(model: UnitModel, selDefs: Dict<SelectionDef>) {\n  const selCmpts: Dict<SelectionComponent<any /* this has to be \"any\" so typing won't fail in test files*/>> = {};\n  const selectionConfig = model.config.selection;\n\n  for (const name in selDefs) {\n    if (!hasOwnProperty(selDefs, name)) {\n      continue;\n    }\n\n    const selDef = duplicate(selDefs[name]);\n    const {fields, encodings, ...cfg} = selectionConfig[selDef.type]; // Project transform applies its defaults.\n\n    // Set default values from config if a property hasn't been specified,\n    // or if it is true. E.g., \"translate\": true should use the default\n    // event handlers for translate. However, true may be a valid value for\n    // a property (e.g., \"nearest\": true).\n    for (const key in cfg) {\n      // A selection should contain either `encodings` or `fields`, only use\n      // default values for these two values if neither of them is specified.\n      if ((key === 'encodings' && selDef.fields) || (key === 'fields' && selDef.encodings)) {\n        continue;\n      }\n\n      if (key === 'mark') {\n        selDef[key] = {...cfg[key], ...selDef[key]};\n      }\n\n      if (selDef[key] === undefined || selDef[key] === true) {\n        selDef[key] = cfg[key] ?? selDef[key];\n      }\n    }\n\n    const safeName = varName(name);\n    const selCmpt = (selCmpts[safeName] = {\n      ...selDef,\n      name: safeName,\n      events: isString(selDef.on) ? parseSelector(selDef.on, 'scope') : duplicate(selDef.on)\n    } as any);\n\n    forEachTransform(selCmpt, txCompiler => {\n      if (txCompiler.has(selCmpt) && txCompiler.parse) {\n        txCompiler.parse(model, selCmpt, selDef, selDefs[name]);\n      }\n    });\n  }\n\n  return selCmpts;\n}\n\nexport function parseSelectionPredicate(\n  model: Model,\n  selections: LogicalOperand<string>,\n  dfnode?: DataFlowNode,\n  datum = 'datum'\n): string {\n  const stores: string[] = [];\n  function expr(name: string): string {\n    const vname = varName(name);\n    const selCmpt = model.getSelectionComponent(vname, name);\n    const store = stringValue(vname + STORE);\n\n    if (selCmpt.project.timeUnit) {\n      const child = dfnode ?? model.component.data.raw;\n      const tunode = selCmpt.project.timeUnit.clone();\n      if (child.parent) {\n        tunode.insertAsParentOf(child);\n      } else {\n        child.parent = tunode;\n      }\n    }\n\n    if (selCmpt.empty !== 'none') {\n      stores.push(store);\n    }\n\n    return (\n      `vlSelectionTest(${store}, ${datum}` + (selCmpt.resolve === 'global' ? ')' : `, ${stringValue(selCmpt.resolve)})`)\n    );\n  }\n\n  const predicateStr = logicalExpr(selections, expr);\n  return (\n    (stores.length ? '!(' + stores.map(s => `length(data(${s}))`).join(' || ') + ') || ' : '') + `(${predicateStr})`\n  );\n}\n\nexport function parseSelectionBinExtent(selCmpt: SelectionComponent, extent: SelectionExtent) {\n  const encoding = extent['encoding'];\n  let field = extent['field'];\n\n  if (!encoding && !field) {\n    field = selCmpt.project.items[0].field;\n    if (selCmpt.project.items.length > 1) {\n      warn(\n        'A \"field\" or \"encoding\" must be specified when using a selection as a scale domain. ' +\n          `Using \"field\": ${stringValue(field)}.`\n      );\n    }\n  } else if (encoding && !field) {\n    const encodings = selCmpt.project.items.filter(p => p.channel === encoding);\n    if (!encodings.length || encodings.length > 1) {\n      field = selCmpt.project.items[0].field;\n      warn(\n        (!encodings.length ? 'No ' : 'Multiple ') +\n          `matching ${stringValue(encoding)} encoding found for selection ${stringValue(extent.selection)}. ` +\n          `Using \"field\": ${stringValue(field)}.`\n      );\n    } else {\n      field = encodings[0].field;\n    }\n  }\n\n  return `${selCmpt.name}[${stringValue(field)}]`;\n}\n\nexport function materializeSelections(model: UnitModel, main: OutputNode) {\n  forEachSelection(model, selCmpt => {\n    const selection = selCmpt.name;\n    const lookupName = model.getName(`lookup_${selection}`);\n    model.component.data.outputNodes[lookupName] = selCmpt.materialized = new OutputNode(\n      new FilterNode(main, model, {selection}),\n      lookupName,\n      'lookup',\n      model.component.data.outputNodeRefCounts\n    );\n  });\n}\n"]}