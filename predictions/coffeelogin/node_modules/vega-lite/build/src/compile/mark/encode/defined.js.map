{"version":3,"file":"defined.js","sourceRoot":"","sources":["../../../../../src/compile/mark/encode/defined.ts"],"names":[],"mappings":"AAEA,OAAO,EAAC,mBAAmB,EAAC,MAAM,gBAAgB,CAAC;AACnD,OAAO,EAAO,IAAI,EAAC,MAAM,eAAe,CAAC;AAEzC,OAAO,EAAC,mBAAmB,EAAC,MAAM,cAAc,CAAC;AAEjD,OAAO,EAAC,qBAAqB,EAAC,MAAM,YAAY,CAAC;AAEjD,MAAM,UAAU,OAAO,CAAC,KAAgB;IACtC,MAAM,EAAC,MAAM,EAAE,OAAO,EAAC,GAAG,KAAK,CAAC;IAEhC,MAAM,OAAO,GAAG,mBAAmB,CAAC,SAAS,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC;IAChE,IAAI,OAAO,EAAE;QACX,MAAM,MAAM,GAAG,yBAAyB,CAAC,KAAK,EAAE,EAAC,QAAQ,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,EAAC,CAAC,CAAC;QAExE,IAAI,MAAM,EAAE;YACV,OAAO,EAAC,OAAO,EAAE,EAAC,MAAM,EAAC,EAAC,CAAC;SAC5B;KACF;IACD,OAAO,EAAE,CAAC;AACZ,CAAC;AAED,SAAS,yBAAyB,CAChC,KAAgB,EAChB,EAAC,OAAO,GAAG,KAAK,EAAE,QAAQ,EAAgD;IAE1E,MAAM,WAAW,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC,UAAsB,EAAE,OAAO,EAAE,EAAE;QACtE,MAAM,cAAc,GAAG,KAAK,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;QACxD,IAAI,cAAc,EAAE;YAClB,MAAM,SAAS,GAAG,cAAc,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;YAC7C,MAAM,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,OAAO,EAAE,EAAC,IAAI,EAAE,OAAO,EAAC,CAAC,CAAC;YAEtD,mFAAmF;YACnF,IAAI,KAAK,IAAI,mBAAmB,CAAC,SAAS,CAAC,EAAE;gBAC3C,UAAU,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC;aAC1B;SACF;QACD,OAAO,UAAU,CAAC;IACpB,CAAC,EAAE,EAAE,CAAC,CAAC;IAEP,MAAM,MAAM,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC;IACjC,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;QACrB,MAAM,EAAE,GAAG,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC;QACjC,OAAO,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,qBAAqB,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;KACnF;IACD,OAAO,SAAS,CAAC;AACnB,CAAC;AAED,MAAM,UAAU,cAAc,CAAC,IAAY,EAAE,KAAY;IACvD,IAAI,KAAK,KAAK,SAAS,EAAE;QACvB,OAAO,EAAC,CAAC,IAAI,CAAC,EAAE,EAAC,KAAK,EAAE,KAAK,EAAC,EAAC,CAAC;KACjC;IACD,OAAO,SAAS,CAAC;AACnB,CAAC","sourcesContent":["import {ScaleChannel} from '../../../channel';\nimport {Value} from '../../../channeldef';\nimport {hasContinuousDomain} from '../../../scale';\nimport {Dict, keys} from '../../../util';\nimport {VgEncodeEntry} from '../../../vega.schema';\nimport {getMarkPropOrConfig} from '../../common';\nimport {UnitModel} from '../../unit';\nimport {fieldInvalidPredicate} from './valueref';\n\nexport function defined(model: UnitModel): VgEncodeEntry {\n  const {config, markDef} = model;\n\n  const invalid = getMarkPropOrConfig('invalid', markDef, config);\n  if (invalid) {\n    const signal = allFieldsInvalidPredicate(model, {channels: ['x', 'y']});\n\n    if (signal) {\n      return {defined: {signal}};\n    }\n  }\n  return {};\n}\n\nfunction allFieldsInvalidPredicate(\n  model: UnitModel,\n  {invalid = false, channels}: {invalid?: boolean; channels: ScaleChannel[]}\n) {\n  const filterIndex = channels.reduce((aggregator: Dict<true>, channel) => {\n    const scaleComponent = model.getScaleComponent(channel);\n    if (scaleComponent) {\n      const scaleType = scaleComponent.get('type');\n      const field = model.vgField(channel, {expr: 'datum'});\n\n      // While discrete domain scales can handle invalid values, continuous scales can't.\n      if (field && hasContinuousDomain(scaleType)) {\n        aggregator[field] = true;\n      }\n    }\n    return aggregator;\n  }, {});\n\n  const fields = keys(filterIndex);\n  if (fields.length > 0) {\n    const op = invalid ? '||' : '&&';\n    return fields.map(field => fieldInvalidPredicate(field, invalid)).join(` ${op} `);\n  }\n  return undefined;\n}\n\nexport function valueIfDefined(prop: string, value: Value): VgEncodeEntry {\n  if (value !== undefined) {\n    return {[prop]: {value: value}};\n  }\n  return undefined;\n}\n"]}