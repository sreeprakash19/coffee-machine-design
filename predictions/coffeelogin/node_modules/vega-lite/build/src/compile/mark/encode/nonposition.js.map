{"version":3,"file":"nonposition.js","sourceRoot":"","sources":["../../../../../src/compile/mark/encode/nonposition.ts"],"names":[],"mappings":"AAEA,OAAO,EAAC,eAAe,EAAC,MAAM,eAAe,CAAC;AAE9C,OAAO,EAAC,aAAa,EAAC,MAAM,cAAc,CAAC;AAE3C,OAAO,EAAC,aAAa,EAAC,MAAM,eAAe,CAAC;AAC5C,OAAO,KAAK,GAAG,MAAM,YAAY,CAAC;AAElC;;GAEG;AACH,MAAM,UAAU,WAAW,CACzB,OAAgC,EAChC,KAAgB,EAChB,MAII,EAAE;IAEN,MAAM,EAAC,OAAO,EAAE,QAAQ,EAAE,MAAM,EAAC,GAAG,KAAK,CAAC;IAC1C,MAAM,EAAC,SAAS,GAAG,OAAO,EAAC,GAAG,GAAG,CAAC;IAClC,IAAI,EAAC,UAAU,EAAE,YAAY,EAAC,GAAG,GAAG,CAAC;IAErC,IAAI,UAAU,KAAK,SAAS,EAAE;QAC5B,kBAAkB;QAClB,YAAY,IAAG,YAAY,aAAZ,YAAY,cAAZ,YAAY,GACzB,CAAC,SAAS,KAAK,OAAO;YACpB,CAAC,CAAC,uGAAuG;gBACzG,OAAO,CAAC,OAAO,CAAC;YAChB,CAAC,CAAC,0GAA0G;gBAC5G,eAAe,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,OAAO,CAAC,SAAS,CAAC,EAAE,aAAa,CAAC,OAAO,EAAE,OAAO,EAAE,MAAM,EAAE,EAAC,SAAS,EAAC,CAAC,CAAC,CAAC,CAAA,CAAC;QAEjH,UAAU,GAAG,YAAY,CAAC,CAAC,CAAC,EAAC,KAAK,EAAE,YAAY,EAAC,CAAC,CAAC,CAAC,SAAS,CAAC;KAC/D;IAED,MAAM,UAAU,GAAG,QAAQ,CAAC,OAAO,CAAC,CAAC;IAErC,OAAO,aAAa,CAAoC,KAAK,EAAE,UAAU,EAAE,SAAS,EAAE,IAAI,CAAC,EAAE;QAC3F,OAAO,GAAG,CAAC,QAAQ,CAAC;YAClB,OAAO;YACP,UAAU,EAAE,IAAI;YAChB,OAAO;YACP,MAAM;YACN,SAAS,EAAE,KAAK,CAAC,SAAS,CAAC,OAAO,CAAC;YACnC,KAAK,EAAE,KAAK,CAAC,iBAAiB,CAAC,OAAO,CAAC;YACvC,KAAK,EAAE,IAAI;YACX,UAAU;SACX,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC","sourcesContent":["import {NonPositionScaleChannel} from '../../../channel';\nimport {FieldDef, ValueOrGradient} from '../../../channeldef';\nimport {getFirstDefined} from '../../../util';\nimport {VgEncodeChannel, VgEncodeEntry, VgValueRef} from '../../../vega.schema';\nimport {getMarkConfig} from '../../common';\nimport {UnitModel} from '../../unit';\nimport {wrapCondition} from './conditional';\nimport * as ref from './valueref';\n\n/**\n * Return encodoing encode for non-positional channels with scales. (Text doesn't have scale.)\n */\nexport function nonPosition(\n  channel: NonPositionScaleChannel,\n  model: UnitModel,\n  opt: {\n    defaultValue?: ValueOrGradient;\n    vgChannel?: VgEncodeChannel;\n    defaultRef?: VgValueRef;\n  } = {}\n): VgEncodeEntry {\n  const {markDef, encoding, config} = model;\n  const {vgChannel = channel} = opt;\n  let {defaultRef, defaultValue} = opt;\n\n  if (defaultRef === undefined) {\n    // prettier-ignore\n    defaultValue = defaultValue ??\n      (vgChannel === channel\n        ? // When vl channel is the same as Vega's, no need to read from config as Vega will apply them correctly\n        markDef[channel]\n        : // However, when they are different (e.g, vl's text size is vg fontSize), need to read \"size\" from configs\n        getFirstDefined(markDef[channel], markDef[vgChannel], getMarkConfig(channel, markDef, config, {vgChannel})));\n\n    defaultRef = defaultValue ? {value: defaultValue} : undefined;\n  }\n\n  const channelDef = encoding[channel];\n\n  return wrapCondition<FieldDef<string>, ValueOrGradient>(model, channelDef, vgChannel, cDef => {\n    return ref.midPoint({\n      channel,\n      channelDef: cDef,\n      markDef,\n      config,\n      scaleName: model.scaleName(channel),\n      scale: model.getScaleComponent(channel),\n      stack: null, // No need to provide stack for non-position as it does not affect mid point\n      defaultRef\n    });\n  });\n}\n"]}