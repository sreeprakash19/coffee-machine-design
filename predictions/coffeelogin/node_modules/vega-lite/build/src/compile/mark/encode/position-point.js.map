{"version":3,"file":"position-point.js","sourceRoot":"","sources":["../../../../../src/compile/mark/encode/position-point.ts"],"names":[],"mappings":"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","sourcesContent":["import {getMainRangeChannel, PositionChannel, X, X2, Y2} from '../../../channel';\nimport {isFieldDef, isPositionFieldDef} from '../../../channeldef';\nimport {Config} from '../../../config';\nimport * as log from '../../../log';\nimport {Mark, MarkDef} from '../../../mark';\nimport {ScaleType} from '../../../scale';\nimport {contains, getFirstDefined} from '../../../util';\nimport {VgValueRef} from '../../../vega.schema';\nimport {getMarkConfig} from '../../common';\nimport {ScaleComponent} from '../../scale/component';\nimport {UnitModel} from '../../unit';\nimport {getOffset} from './offset';\nimport * as ref from './valueref';\n\n/**\n * Return encode for point (non-band) position channels.\n */\nexport function pointPosition(\n  channel: 'x' | 'y',\n  model: UnitModel,\n  {defaultPos, vgChannel}: {defaultPos: 'mid' | 'zeroOrMin' | 'zeroOrMax'; vgChannel?: 'x' | 'y' | 'xc' | 'yc'}\n) {\n  // TODO: refactor how refer to scale as discussed in https://github.com/vega/vega-lite/pull/1613\n\n  const {encoding, mark, markDef, config, stack} = model;\n\n  const channelDef = encoding[channel];\n  const channel2Def = encoding[channel === X ? X2 : Y2];\n  const scaleName = model.scaleName(channel);\n  const scale = model.getScaleComponent(channel);\n\n  const offset = getOffset(channel, model.markDef);\n\n  const defaultRef = pointPositionDefaultRef({\n    model,\n    markDef,\n    config,\n    defaultPos,\n    channel,\n    scaleName,\n    scale,\n    mark,\n    checkBarAreaWithoutZero: !channel2Def // only check for non-ranged marks\n  });\n\n  const valueRef =\n    !channelDef && (encoding.latitude || encoding.longitude)\n      ? // use geopoint output if there are lat/long and there is no point position overriding lat/long.\n        {field: model.getName(channel)}\n      : positionRef({\n          channel,\n          channelDef,\n          channel2Def,\n          markDef,\n          config,\n          scaleName,\n          scale,\n          stack,\n          offset,\n          defaultRef\n        });\n\n  return {\n    [vgChannel ?? channel]: valueRef\n  };\n}\n\n// TODO: we need to find a way to refactor these so that scaleName is a part of scale\n// but that's complicated. For now, this is a huge step moving forward.\n\n/**\n * @return Vega ValueRef for normal x- or y-position without projection\n */\nfunction positionRef(\n  params: ref.MidPointParams & {\n    channel: 'x' | 'y';\n  }\n): VgValueRef | VgValueRef[] {\n  const {channel, channelDef, scaleName, stack, offset} = params;\n\n  // This isn't a part of midPoint because we use midPoint for non-position too\n  if (isFieldDef(channelDef) && stack && channel === stack.fieldChannel) {\n    if (isPositionFieldDef(channelDef) && channelDef.band !== undefined) {\n      return ref.interpolatedSignalRef({\n        scaleName,\n        fieldDef: channelDef,\n        startSuffix: 'start',\n        band: channelDef.band,\n        offset: 0\n      });\n    }\n    // x or y use stack_end so that stacked line's point mark use stack_end too.\n    return ref.fieldRef(channelDef, scaleName, {suffix: 'end'}, {offset});\n  }\n\n  return ref.midPointRefWithPositionInvalidTest(params);\n}\n\nexport function pointPositionDefaultRef({\n  model,\n  markDef,\n  config,\n  defaultPos,\n  channel,\n  scaleName,\n  scale,\n  mark,\n  checkBarAreaWithoutZero: checkBarAreaWithZero\n}: {\n  model: UnitModel;\n  markDef: MarkDef;\n  config: Config;\n  defaultPos: 'mid' | 'zeroOrMin' | 'zeroOrMax';\n  channel: PositionChannel;\n  scaleName: string;\n  scale: ScaleComponent;\n  mark: Mark;\n  checkBarAreaWithoutZero: boolean;\n}) {\n  return () => {\n    const mainChannel = getMainRangeChannel(channel);\n\n    const definedValueOrConfig = getFirstDefined(markDef[channel], getMarkConfig(channel, markDef, config));\n    if (definedValueOrConfig !== undefined) {\n      return ref.widthHeightValueRef(channel, definedValueOrConfig);\n    }\n\n    if (defaultPos === 'zeroOrMin' || defaultPos === 'zeroOrMax') {\n      if (scaleName) {\n        const scaleType = scale.get('type');\n        if (contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scaleType)) {\n          // Log scales cannot have zero.\n          // Zero in time scale is arbitrary, and does not affect ratio.\n          // (Time is an interval level of measurement, not ratio).\n          // See https://en.wikipedia.org/wiki/Level_of_measurement for more info.\n          if (checkBarAreaWithZero && (mark === 'bar' || mark === 'area')) {\n            log.warn(log.message.nonZeroScaleUsedWithLengthMark(mark, mainChannel, {scaleType}));\n          }\n        } else {\n          if (scale.domainDefinitelyIncludesZero()) {\n            return {\n              scale: scaleName,\n              value: 0\n            };\n          }\n          if (checkBarAreaWithZero && (mark === 'bar' || mark === 'area')) {\n            log.warn(\n              log.message.nonZeroScaleUsedWithLengthMark(mark, mainChannel, {zeroFalse: scale.explicit.zero === false})\n            );\n          }\n        }\n      }\n\n      if (defaultPos === 'zeroOrMin') {\n        return mainChannel === 'x' ? {value: 0} : {field: {group: 'height'}};\n      } else {\n        // zeroOrMax\n        return mainChannel === 'x' ? {field: {group: 'width'}} : {value: 0};\n      }\n    } else {\n      // mid\n      const sizeRef = model[mainChannel === 'x' ? 'width' : 'height'];\n      return {...sizeRef, mult: 0.5};\n    }\n  };\n}\n"]}