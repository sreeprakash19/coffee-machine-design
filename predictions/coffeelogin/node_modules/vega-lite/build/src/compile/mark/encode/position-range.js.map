{"version":3,"file":"position-range.js","sourceRoot":"","sources":["../../../../../src/compile/mark/encode/position-range.ts"],"names":[],"mappings":"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","sourcesContent":["import {isFieldDef} from '../../../channeldef';\nimport {MarkConfig} from '../../../mark';\nimport {getFirstDefined} from '../../../util';\nimport {VgEncodeEntry, VgValueRef} from '../../../vega.schema';\nimport {getStyleConfig} from '../../common';\nimport {UnitModel} from '../../unit';\nimport {getOffset} from './offset';\nimport {alignedPositionChannel} from './position-align';\nimport {pointPosition, pointPositionDefaultRef} from './position-point';\nimport * as ref from './valueref';\n\nexport function pointOrRangePosition(\n  channel: 'x' | 'y',\n  model: UnitModel,\n  {\n    defaultPos,\n    defaultPos2,\n    range\n  }: {\n    defaultPos: 'zeroOrMin' | 'zeroOrMax' | 'mid';\n    defaultPos2: 'zeroOrMin' | 'zeroOrMax';\n    range: boolean;\n  }\n) {\n  if (range) {\n    return rangePosition(channel, model, {defaultPos, defaultPos2});\n  }\n  return pointPosition(channel, model, {defaultPos});\n}\n\nexport function rangePosition(\n  channel: 'x' | 'y',\n  model: UnitModel,\n  {\n    defaultPos,\n    defaultPos2\n  }: {\n    defaultPos: 'zeroOrMin' | 'zeroOrMax' | 'mid';\n    defaultPos2: 'zeroOrMin' | 'zeroOrMax';\n  }\n) {\n  const {markDef, config} = model;\n  const channel2 = channel === 'x' ? 'x2' : 'y2';\n  const sizeChannel = channel === 'x' ? 'width' : 'height';\n\n  const pos2Mixins = pointPosition2(model, defaultPos2, channel2);\n\n  const vgChannel = pos2Mixins[sizeChannel] ? alignedPositionChannel(channel, markDef, config) : channel;\n\n  return {\n    ...pointPosition(channel, model, {defaultPos, vgChannel}),\n    ...pos2Mixins\n  };\n}\n\n/**\n * Return encode for x2, y2.\n * If channel is not specified, return one channel based on orientation.\n */\nfunction pointPosition2(model: UnitModel, defaultPos: 'zeroOrMin' | 'zeroOrMax', channel: 'x2' | 'y2') {\n  const {encoding, mark, markDef, stack, config} = model;\n\n  const baseChannel = channel === 'x2' ? 'x' : 'y';\n  const sizeChannel = channel === 'x2' ? 'width' : 'height';\n\n  const channelDef = encoding[baseChannel];\n  const scaleName = model.scaleName(baseChannel);\n  const scale = model.getScaleComponent(baseChannel);\n\n  const offset = getOffset(channel, model.markDef);\n\n  if (!channelDef && (encoding.latitude || encoding.longitude)) {\n    // use geopoint output if there are lat2/long2 and there is no point position2 overriding lat2/long2.\n    return {[channel]: {field: model.getName(channel)}};\n  }\n\n  const valueRef = position2Ref({\n    channel,\n    channelDef,\n    channel2Def: encoding[channel],\n    markDef,\n    config,\n    scaleName,\n    scale,\n    stack,\n    offset,\n    defaultRef: undefined\n  });\n\n  if (valueRef !== undefined) {\n    return {[channel]: valueRef};\n  }\n\n  const defaultRef = pointPositionDefaultRef({\n    model,\n    markDef,\n    config,\n    defaultPos,\n    channel,\n    scaleName,\n    scale,\n    mark,\n    checkBarAreaWithoutZero: !encoding[channel] // only check for non-ranged marks\n  })();\n\n  // TODO: check width/height encoding here once we add them\n\n  // no x2/y2 encoding, then try to read x2/y2 or width/height based on precedence:\n  // markDef > config.style > mark-specific config (config[mark]) > general mark config (config.mark)\n  return getFirstDefined<VgEncodeEntry>(\n    position2orSize(channel, markDef),\n    position2orSize(channel, {\n      [channel]: getStyleConfig(channel, markDef, config.style),\n      [sizeChannel]: getStyleConfig(sizeChannel, markDef, config.style)\n    }),\n    position2orSize(channel, config[mark]),\n    position2orSize(channel, config.mark),\n    {\n      [channel]: defaultRef\n    }\n  );\n}\n\nfunction position2Ref({\n  channel,\n  channelDef,\n  channel2Def,\n  markDef,\n  config,\n  scaleName,\n  scale,\n  stack,\n  offset,\n  defaultRef\n}: ref.MidPointParams & {\n  channel: 'x2' | 'y2';\n}): VgValueRef | VgValueRef[] {\n  if (\n    isFieldDef(channelDef) &&\n    stack &&\n    // If fieldChannel is X and channel is X2 (or Y and Y2)\n    channel.charAt(0) === stack.fieldChannel.charAt(0)\n  ) {\n    return ref.fieldRef(channelDef, scaleName, {suffix: 'start'}, {offset});\n  }\n  return ref.midPointRefWithPositionInvalidTest({\n    channel,\n    channelDef: channel2Def,\n    scaleName,\n    scale,\n    stack,\n    markDef,\n    config,\n    offset,\n    defaultRef\n  });\n}\n\nfunction position2orSize(channel: 'x2' | 'y2', markDef: MarkConfig) {\n  const sizeChannel = channel === 'x2' ? 'width' : 'height';\n  if (markDef[channel]) {\n    return {[channel]: ref.widthHeightValueRef(channel, markDef[channel])};\n  } else if (markDef[sizeChannel]) {\n    return {[sizeChannel]: {value: markDef[sizeChannel]}};\n  }\n  return undefined;\n}\n"]}