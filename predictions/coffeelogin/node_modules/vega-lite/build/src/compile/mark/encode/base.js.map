{"version":3,"file":"base.js","sourceRoot":"","sources":["../../../../../src/compile/mark/encode/base.ts"],"names":[],"mappings":"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","sourcesContent":["import {array} from 'vega-util';\nimport {Channel, ScaleChannel, SCALE_CHANNELS} from '../../../channel';\nimport {isPathMark, MarkDef} from '../../../mark';\nimport {hasContinuousDomain} from '../../../scale';\nimport {Dict, keys} from '../../../util';\nimport {VgEncodeEntry, VgValueRef, VG_MARK_CONFIGS} from '../../../vega.schema';\nimport {getMarkPropOrConfig} from '../../common';\nimport {UnitModel} from '../../unit';\nimport {color} from './color';\nimport {nonPosition} from './nonposition';\nimport {text} from './text';\nimport {tooltip} from './tooltip';\nimport {fieldInvalidPredicate} from './valueref';\n\nexport {color} from './color';\nexport {wrapCondition} from './conditional';\nexport {nonPosition} from './nonposition';\nexport {pointPosition} from './position-point';\nexport {pointOrRangePosition, rangePosition} from './position-range';\nexport {rectPosition} from './position-rect';\nexport {text} from './text';\nexport {tooltip} from './tooltip';\n\nexport type Ignore = Record<'color' | 'size' | 'orient' | 'align' | 'baseline', 'ignore' | 'include'>;\n\nexport function baseEncodeEntry(model: UnitModel, ignore: Ignore) {\n  const {fill = undefined, stroke = undefined} = ignore.color === 'include' ? color(model) : {};\n  return {\n    ...markDefProperties(model.markDef, ignore),\n    ...wrapAllFieldsInvalid(model, 'fill', fill),\n    ...wrapAllFieldsInvalid(model, 'stroke', stroke),\n    ...nonPosition('opacity', model),\n    ...nonPosition('fillOpacity', model),\n    ...nonPosition('strokeOpacity', model),\n    ...nonPosition('strokeWidth', model),\n    ...tooltip(model),\n    ...text(model, 'href')\n  };\n}\n\n// TODO: mark VgValueRef[] as readonly after https://github.com/vega/vega/pull/1987\nfunction wrapAllFieldsInvalid(model: UnitModel, channel: Channel, valueRef: VgValueRef | VgValueRef[]): VgEncodeEntry {\n  const {config, mark, markDef} = model;\n\n  const invalid = getMarkPropOrConfig('invalid', markDef, config);\n\n  if (invalid === 'hide' && valueRef && !isPathMark(mark)) {\n    // For non-path marks, we have to exclude invalid values (null and NaN) for scales with continuous domains.\n    // For path marks, we will use \"defined\" property and skip these values instead.\n    const test = allFieldsInvalidPredicate(model, {invalid: true, channels: SCALE_CHANNELS});\n    if (test) {\n      return {\n        [channel]: [\n          // prepend the invalid case\n          // TODO: support custom value\n          {test, value: null},\n          ...array(valueRef)\n        ]\n      };\n    }\n  }\n  return valueRef ? {[channel]: valueRef} : {};\n}\n\nfunction markDefProperties(mark: MarkDef, ignore: Ignore) {\n  return VG_MARK_CONFIGS.reduce((m, prop) => {\n    if (mark[prop] !== undefined && ignore[prop] !== 'ignore') {\n      m[prop] = {value: mark[prop]};\n    }\n    return m;\n  }, {});\n}\n\nfunction allFieldsInvalidPredicate(\n  model: UnitModel,\n  {invalid = false, channels}: {invalid?: boolean; channels: ScaleChannel[]}\n) {\n  const filterIndex = channels.reduce((aggregator: Dict<true>, channel) => {\n    const scaleComponent = model.getScaleComponent(channel);\n    if (scaleComponent) {\n      const scaleType = scaleComponent.get('type');\n      const field = model.vgField(channel, {expr: 'datum'});\n\n      // While discrete domain scales can handle invalid values, continuous scales can't.\n      if (field && hasContinuousDomain(scaleType)) {\n        aggregator[field] = true;\n      }\n    }\n    return aggregator;\n  }, {});\n\n  const fields = keys(filterIndex);\n  if (fields.length > 0) {\n    const op = invalid ? '||' : '&&';\n    return fields.map(field => fieldInvalidPredicate(field, invalid)).join(` ${op} `);\n  }\n  return undefined;\n}\n"]}