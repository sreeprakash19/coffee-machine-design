import { getFirstDefined } from '../../../util';
import { getMarkConfig } from '../../common';
import { wrapCondition } from './conditional';
import * as ref from './valueref';
/**
 * Return encodoing encode for non-positional channels with scales. (Text doesn't have scale.)
 */
export function nonPosition(channel, model, opt = {}) {
    const { markDef, encoding, config } = model;
    const { vgChannel = channel } = opt;
    let { defaultRef, defaultValue } = opt;
    if (defaultRef === undefined) {
        // prettier-ignore
        defaultValue = (defaultValue !== null && defaultValue !== void 0 ? defaultValue : (vgChannel === channel
            ? // When vl channel is the same as Vega's, no need to read from config as Vega will apply them correctly
                markDef[channel]
            : // However, when they are different (e.g, vl's text size is vg fontSize), need to read "size" from configs
                getFirstDefined(markDef[channel], markDef[vgChannel], getMarkConfig(channel, markDef, config, { vgChannel }))));
        defaultRef = defaultValue ? { value: defaultValue } : undefined;
    }
    const channelDef = encoding[channel];
    return wrapCondition(model, channelDef, vgChannel, cDef => {
        return ref.midPoint({
            channel,
            channelDef: cDef,
            markDef,
            config,
            scaleName: model.scaleName(channel),
            scale: model.getScaleComponent(channel),
            stack: null,
            defaultRef
        });
    });
}
//# sourceMappingURL=nonposition.js.map