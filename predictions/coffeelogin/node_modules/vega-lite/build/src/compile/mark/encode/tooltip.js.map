{"version":3,"file":"tooltip.js","sourceRoot":"","sources":["../../../../../src/compile/mark/encode/tooltip.ts"],"names":[],"mappings":"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","sourcesContent":["import {array, isArray, isObject, isString, stringValue} from 'vega-util';\nimport {isBinned} from '../../../bin';\nimport {Channel, getMainRangeChannel} from '../../../channel';\nimport {\n  format,\n  getFieldDef,\n  hasConditionalFieldDef,\n  isFieldDef,\n  isTypedFieldDef,\n  SecondaryFieldDef,\n  title,\n  TypedFieldDef,\n  vgField\n} from '../../../channeldef';\nimport {Config} from '../../../config';\nimport {Encoding, forEach} from '../../../encoding';\nimport {getFirstDefined} from '../../../util';\nimport {binFormatExpression, getMarkConfig} from '../../common';\nimport {UnitModel} from '../../unit';\nimport {wrapCondition} from './conditional';\nimport {textRef} from './text';\n\nexport function tooltip(model: UnitModel, opt: {reactiveGeom?: boolean} = {}) {\n  const {encoding, markDef, config} = model;\n  const channelDef = encoding.tooltip;\n  if (isArray(channelDef)) {\n    return {tooltip: tooltipRefForEncoding({tooltip: channelDef}, config, opt)};\n  } else {\n    return wrapCondition(model, channelDef, 'tooltip', cDef => {\n      // use valueRef based on channelDef first\n      const tooltipRefFromChannelDef = textRef(cDef, model.config, opt.reactiveGeom ? 'datum.datum' : 'datum');\n      if (tooltipRefFromChannelDef) {\n        return tooltipRefFromChannelDef;\n      }\n\n      if (cDef === null) {\n        // Allow using encoding.tooltip = null to disable tooltip\n        return undefined;\n      }\n\n      // If tooltipDef does not exist, then use value from markDef or config\n      let markTooltip = getFirstDefined(markDef.tooltip, getMarkConfig('tooltip', markDef, config));\n\n      if (markTooltip === true) {\n        markTooltip = {content: 'encoding'};\n      }\n\n      if (isString(markTooltip)) {\n        return {value: markTooltip};\n      } else if (isObject(markTooltip)) {\n        // `tooltip` is `{fields: 'encodings' | 'fields'}`\n        if (markTooltip.content === 'encoding') {\n          return tooltipRefForEncoding(encoding, config, opt);\n        } else {\n          return {signal: 'datum'};\n        }\n      }\n\n      return undefined;\n    });\n  }\n}\n\nexport function tooltipRefForEncoding(\n  encoding: Encoding<string>,\n  config: Config,\n  {reactiveGeom}: {reactiveGeom?: boolean} = {}\n) {\n  const keyValues: string[] = [];\n  const usedKey = {};\n  const toSkip = {};\n  const expr = reactiveGeom ? 'datum.datum' : 'datum';\n  const tooltipTuples: {channel: Channel; key: string; value: string}[] = [];\n\n  function add(fDef: TypedFieldDef<string> | SecondaryFieldDef<string>, channel: Channel) {\n    const mainChannel = getMainRangeChannel(channel);\n\n    const fieldDef: TypedFieldDef<string> = isTypedFieldDef(fDef)\n      ? fDef\n      : {\n          ...fDef,\n          type: encoding[mainChannel].type // for secondary field def, copy type from main channel\n        };\n\n    const key = array(title(fieldDef, config, {allowDisabling: false})).join(', ');\n\n    let value = textRef(fieldDef, config, expr).signal;\n\n    if (channel === 'x' || channel === 'y') {\n      const channel2 = channel === 'x' ? 'x2' : 'y2';\n      const fieldDef2 = getFieldDef(encoding[channel2]);\n\n      if (isBinned(fieldDef.bin) && fieldDef2) {\n        const startField = vgField(fieldDef, {expr});\n        const endField = vgField(fieldDef2, {expr});\n        value = binFormatExpression(startField, endField, format(fieldDef), config);\n        toSkip[channel2] = true;\n      }\n    }\n\n    tooltipTuples.push({channel, key, value});\n  }\n\n  forEach(encoding, (channelDef, channel) => {\n    if (isFieldDef(channelDef)) {\n      add(channelDef, channel);\n    } else if (hasConditionalFieldDef(channelDef)) {\n      add(channelDef.condition, channel);\n    }\n  });\n\n  for (const {channel, key, value} of tooltipTuples) {\n    if (!toSkip[channel] && !usedKey[key]) {\n      keyValues.push(`${stringValue(key)}: ${value}`);\n      usedKey[key] = true;\n    }\n  }\n\n  return keyValues.length > 0 ? {signal: `{${keyValues.join(', ')}}`} : undefined;\n}\n"]}