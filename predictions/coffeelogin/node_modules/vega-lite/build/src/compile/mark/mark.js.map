{"version":3,"file":"mark.js","sourceRoot":"","sources":["../../../../src/compile/mark/mark.ts"],"names":[],"mappings":"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","sourcesContent":["import {isArray} from 'vega-util';\nimport {FieldRefOption, isFieldDef, isValueDef, vgField} from '../../channeldef';\nimport {MAIN} from '../../data';\nimport {isAggregate, pathGroupingFields} from '../../encoding';\nimport {AREA, BAR, isPathMark, LINE, Mark, TRAIL} from '../../mark';\nimport {isSortByEncoding, isSortField} from '../../sort';\nimport {contains, getFirstDefined, isNullOrFalse, keys, omit, pick} from '../../util';\nimport {VgCompare, VgEncodeEntry, VG_CORNERRADIUS_CHANNELS} from '../../vega.schema';\nimport {getMarkConfig, getStyles, sortParams} from '../common';\nimport {UnitModel} from '../unit';\nimport {area} from './area';\nimport {bar} from './bar';\nimport {MarkCompiler} from './base';\nimport {geoshape} from './geoshape';\nimport {image} from './image';\nimport {line, trail} from './line';\nimport {circle, point, square} from './point';\nimport {rect} from './rect';\nimport {rule} from './rule';\nimport {text} from './text';\nimport {tick} from './tick';\n\nconst markCompiler: {[m in Mark]: MarkCompiler} = {\n  area,\n  bar,\n  circle,\n  geoshape,\n  image,\n  line,\n  point,\n  rect,\n  rule,\n  square,\n  text,\n  tick,\n  trail\n};\n\nexport function parseMarkGroups(model: UnitModel): any[] {\n  if (contains([LINE, AREA, TRAIL], model.mark)) {\n    return parsePathMark(model);\n  } else if (contains([BAR], model.mark)) {\n    return getStackGroups(model);\n  } else {\n    return getMarkGroups(model);\n  }\n}\n\nconst FACETED_PATH_PREFIX = 'faceted_path_';\n\nfunction parsePathMark(model: UnitModel) {\n  const details = pathGroupingFields(model.mark, model.encoding);\n\n  const pathMarks = getMarkGroups(model, {\n    // If has subfacet for line/area group, need to use faceted data from below.\n    fromPrefix: details.length > 0 ? FACETED_PATH_PREFIX : ''\n  });\n\n  if (details.length > 0) {\n    // have level of details - need to facet line into subgroups\n    // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)\n\n    return [\n      {\n        name: model.getName('pathgroup'),\n        type: 'group',\n        from: {\n          facet: {\n            name: FACETED_PATH_PREFIX + model.requestDataName(MAIN),\n            data: model.requestDataName(MAIN),\n            groupby: details\n          }\n        },\n        encode: {\n          update: {\n            width: {field: {group: 'width'}},\n            height: {field: {group: 'height'}}\n          }\n        },\n        marks: pathMarks\n      }\n    ];\n  } else {\n    return pathMarks;\n  }\n}\n\nconst STACK_GROUP_PREFIX = 'stack_group_';\n\n/**\n * We need to put stacked bars into groups in order to enable cornerRadius for stacks.\n * If stack is used and the model doesn't have size encoding, we put the mark into groups,\n * and apply cornerRadius properties at the group.\n */\nfunction getStackGroups(model: UnitModel) {\n  // Don't use nested groups when cornerRadius is not specified, or specified as 0\n  const hasCornerRadius = VG_CORNERRADIUS_CHANNELS.some(\n    prop => model.markDef[prop] || getMarkConfig(prop, model.markDef, model.config)\n  );\n\n  // Activate groups if stack is used and the model doesn't have size encoding\n  if (model.stack && !model.fieldDef('size') && hasCornerRadius) {\n    // Generate the mark\n    const [mark] = getMarkGroups(model, {fromPrefix: STACK_GROUP_PREFIX});\n\n    // Get the scale for the stacked field\n    const fieldScale = model.scaleName(model.stack.fieldChannel);\n    const stackField = (opt: FieldRefOption = {}) => model.vgField(model.stack.fieldChannel, opt);\n    // Find the min/max of the pixel value on the stacked direction\n    const stackFieldGroup = (func: 'min' | 'max', expr: 'datum' | 'parent') => {\n      const vgFieldMinMax = [\n        stackField({prefix: 'min', suffix: 'start', expr}),\n        stackField({prefix: 'max', suffix: 'start', expr}),\n        stackField({prefix: 'min', suffix: 'end', expr}),\n        stackField({prefix: 'max', suffix: 'end', expr})\n      ];\n      return `${func}(${vgFieldMinMax.map(field => `scale('${fieldScale}',${field})`).join(',')})`;\n    };\n\n    let groupUpdate: VgEncodeEntry;\n    let innerGroupUpdate: VgEncodeEntry;\n\n    // Build the encoding for group and an inner group\n    if (model.stack.fieldChannel === 'x') {\n      // Move cornerRadius, y/yc/y2/height properties to group\n      // Group x/x2 should be the min/max of the marks within\n      groupUpdate = {\n        ...pick(mark.encode.update, ['y', 'yc', 'y2', 'height', ...VG_CORNERRADIUS_CHANNELS]),\n        x: {signal: stackFieldGroup('min', 'datum')},\n        x2: {signal: stackFieldGroup('max', 'datum')},\n        clip: {value: true}\n      };\n      // Inner group should revert the x translation, and pass height through\n      innerGroupUpdate = {\n        x: {field: {group: 'x'}, mult: -1},\n        height: {field: {group: 'height'}}\n      };\n      // The marks should use the same height as group, without y/yc/y2 properties (because it's already done by group)\n      // This is why size encoding is not supported yet\n      mark.encode.update = {\n        ...omit(mark.encode.update, ['y', 'yc', 'y2']),\n        height: {field: {group: 'height'}}\n      };\n    } else {\n      groupUpdate = {\n        ...pick(mark.encode.update, ['x', 'xc', 'x2', 'width']),\n        y: {signal: stackFieldGroup('min', 'datum')},\n        y2: {signal: stackFieldGroup('max', 'datum')},\n        clip: {value: true}\n      };\n      innerGroupUpdate = {\n        y: {field: {group: 'y'}, mult: -1},\n        width: {field: {group: 'width'}}\n      };\n      mark.encode.update = {\n        ...omit(mark.encode.update, ['x', 'xc', 'x2']),\n        width: {field: {group: 'width'}}\n      };\n    }\n\n    // Deal with cornerRadius properties\n    for (const key of VG_CORNERRADIUS_CHANNELS) {\n      const configValue = getMarkConfig(key, model.markDef, model.config);\n      // Move from mark to group\n      if (mark.encode.update[key]) {\n        groupUpdate[key] = mark.encode.update[key];\n        delete mark.encode.update[key];\n      } else if (configValue) {\n        groupUpdate[key] = {value: configValue};\n      }\n      // Overwrite any cornerRadius on mark set by config --- they are already moved to the group\n      if (configValue) {\n        mark.encode.update[key] = {value: 0};\n      }\n    }\n\n    // For bin we have to add bin channels.\n    const groupby: string[] = model.vgField(model.stack.groupbyChannel)\n      ? [model.vgField(model.stack.groupbyChannel)]\n      : [];\n    if (model.fieldDef(model.stack.groupbyChannel)?.bin) {\n      groupby.push(model.vgField(model.stack.groupbyChannel, {binSuffix: 'end'}));\n    }\n\n    const strokeProperties = [\n      'stroke',\n      'strokeWidth',\n      'strokeJoin',\n      'strokeCap',\n      'strokeDash',\n      'strokeDashOffset',\n      'strokeMiterLimit',\n      'strokeOpacity'\n    ] as const;\n\n    // Generate stroke properties for the group\n    groupUpdate = strokeProperties.reduce((encode, prop) => {\n      if (mark.encode.update[prop]) {\n        return {...encode, [prop]: mark.encode.update[prop]};\n      } else {\n        const configValue = getMarkConfig(prop, model.markDef, model.config);\n        if (configValue !== undefined) {\n          return {...encode, [prop]: {value: configValue}};\n        } else {\n          return encode;\n        }\n      }\n    }, groupUpdate);\n\n    // Apply strokeForeground and strokeOffset if stroke is used\n    if (groupUpdate.stroke) {\n      groupUpdate.strokeForeground = {value: true};\n      groupUpdate.strokeOffset = {value: 0};\n    }\n\n    return [\n      {\n        type: 'group',\n        from: {\n          facet: {\n            data: model.requestDataName(MAIN),\n            name: STACK_GROUP_PREFIX + model.requestDataName(MAIN),\n            groupby,\n            aggregate: {\n              fields: [\n                stackField({suffix: 'start'}),\n                stackField({suffix: 'start'}),\n                stackField({suffix: 'end'}),\n                stackField({suffix: 'end'})\n              ],\n              ops: ['min', 'max', 'min', 'max']\n            }\n          }\n        },\n        encode: {\n          update: groupUpdate\n        },\n        marks: [\n          {\n            type: 'group',\n            encode: {update: innerGroupUpdate},\n            marks: [mark]\n          }\n        ]\n      }\n    ];\n  } else {\n    return getMarkGroups(model);\n  }\n}\n\nexport function getSort(model: UnitModel): VgCompare {\n  const {encoding, stack, mark, markDef, config} = model;\n  const order = encoding.order;\n  if (\n    (!isArray(order) && isValueDef(order) && isNullOrFalse(order.value)) ||\n    (!order && isNullOrFalse(markDef.order)) ||\n    isNullOrFalse(getMarkConfig('order', markDef, config))\n  ) {\n    return undefined;\n  } else if ((isArray(order) || isFieldDef(order)) && !stack) {\n    // Sort by the order field if it is specified and the field is not stacked. (For stacked field, order specify stack order.)\n    return sortParams(order, {expr: 'datum'});\n  } else if (isPathMark(mark)) {\n    // For both line and area, we sort values based on dimension by default\n    const dimensionChannel = markDef.orient === 'horizontal' ? 'y' : 'x';\n    const dimensionChannelDef = encoding[dimensionChannel];\n    if (isFieldDef(dimensionChannelDef)) {\n      const s = dimensionChannelDef.sort;\n\n      if (isArray(s)) {\n        return {\n          field: vgField(dimensionChannelDef, {prefix: dimensionChannel, suffix: 'sort_index', expr: 'datum'})\n        };\n      } else if (isSortField(s)) {\n        return {\n          field: vgField(\n            {\n              // FIXME: this op might not already exist?\n              // FIXME: what if dimensionChannel (x or y) contains custom domain?\n              aggregate: isAggregate(model.encoding) ? s.op : undefined,\n              field: s.field\n            },\n            {expr: 'datum'}\n          )\n        };\n      } else if (isSortByEncoding(s)) {\n        const fieldDefToSort = model.fieldDef(s.encoding);\n        return {\n          field: vgField(fieldDefToSort, {expr: 'datum'}),\n          order: s.order\n        };\n      } else {\n        return {\n          field: vgField(dimensionChannelDef, {\n            // For stack with imputation, we only have bin_mid\n            binSuffix: model.stack && model.stack.impute ? 'mid' : undefined,\n            expr: 'datum'\n          })\n        };\n      }\n    }\n    return undefined;\n  }\n  return undefined;\n}\n\nfunction getMarkGroups(\n  model: UnitModel,\n  opt: {\n    fromPrefix: string;\n  } = {fromPrefix: ''}\n) {\n  const mark = model.mark;\n\n  const clip = getFirstDefined(model.markDef.clip, scaleClip(model), projectionClip(model));\n  const style = getStyles(model.markDef);\n  const key = model.encoding.key;\n  const sort = getSort(model);\n  const interactive = interactiveFlag(model);\n\n  const postEncodingTransform = markCompiler[mark].postEncodingTransform\n    ? markCompiler[mark].postEncodingTransform(model)\n    : null;\n\n  return [\n    {\n      name: model.getName('marks'),\n      type: markCompiler[mark].vgMark,\n      ...(clip ? {clip: true} : {}),\n      ...(style ? {style} : {}),\n      ...(key ? {key: key.field} : {}),\n      ...(sort ? {sort} : {}),\n      ...(interactive ? interactive : {}),\n      from: {data: opt.fromPrefix + model.requestDataName(MAIN)},\n      encode: {\n        update: markCompiler[mark].encodeEntry(model)\n      },\n      ...(postEncodingTransform\n        ? {\n            transform: postEncodingTransform\n          }\n        : {})\n    }\n  ];\n}\n\n/**\n * If scales are bound to interval selections, we want to automatically clip\n * marks to account for panning/zooming interactions. We identify bound scales\n * by the selectionExtent property, which gets added during scale parsing.\n */\nfunction scaleClip(model: UnitModel) {\n  const xScale = model.getScaleComponent('x');\n  const yScale = model.getScaleComponent('y');\n  return (xScale && xScale.get('selectionExtent')) || (yScale && yScale.get('selectionExtent')) ? true : undefined;\n}\n\n/**\n * If we use a custom projection with auto-fitting to the geodata extent,\n * we need to clip to ensure the chart size doesn't explode.\n */\nfunction projectionClip(model: UnitModel) {\n  const projection = model.component.projection;\n  return projection && !projection.isFit ? true : undefined;\n}\n\n/**\n * Only output interactive flags if we have selections defined somewhere in our model hierarchy.\n */\nfunction interactiveFlag(model: UnitModel) {\n  if (!model.component.selection) return null;\n  const unitCount = keys(model.component.selection).length;\n  let parentCount = unitCount;\n  let parent = model.parent;\n  while (parent && parentCount === 0) {\n    parentCount = keys(parent.component.selection).length;\n    parent = parent.parent;\n  }\n  return parentCount ? {interactive: unitCount > 0} : null;\n}\n"]}