{"version":3,"file":"encode.js","sourceRoot":"","sources":["../../../../src/compile/legend/encode.ts"],"names":[],"mappings":"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","sourcesContent":["import {ColorValueRef, SymbolEncodeEntry} from 'vega';\nimport {isArray, stringValue} from 'vega-util';\nimport {COLOR, NonPositionScaleChannel, OPACITY} from '../../channel';\nimport {\n  Conditional,\n  FieldDefWithCondition,\n  Gradient,\n  hasConditionalValueDef,\n  isTimeFormatFieldDef,\n  isValueDef,\n  MarkPropFieldDef,\n  TypedFieldDef,\n  Value,\n  ValueDef,\n  ValueDefWithCondition\n} from '../../channeldef';\nimport {FILL_STROKE_CONFIG} from '../../mark';\nimport {ScaleType} from '../../scale';\nimport {getFirstDefined, keys, varName} from '../../util';\nimport {applyMarkConfig, timeFormatExpression} from '../common';\nimport * as mixins from '../mark/encode';\nimport {STORE} from '../selection';\nimport {UnitModel} from '../unit';\nimport {ScaleChannel} from './../../channel';\nimport {LegendComponent} from './component';\nimport {defaultType} from './properties';\n\nfunction type(legendCmp: LegendComponent, model: UnitModel, channel: ScaleChannel) {\n  const scaleType = model.getScaleComponent(channel).get('type');\n  return getFirstDefined(legendCmp.get('type'), defaultType({channel, scaleType, alwaysReturn: true}));\n}\n\nexport function symbols(\n  fieldDef: TypedFieldDef<string>,\n  symbolsSpec: any,\n  model: UnitModel,\n  channel: ScaleChannel,\n  legendCmp: LegendComponent\n): SymbolEncodeEntry {\n  if (type(legendCmp, model, channel) !== 'symbol') {\n    return undefined;\n  }\n\n  let out = {\n    ...applyMarkConfig({}, model, FILL_STROKE_CONFIG),\n    ...mixins.color(model)\n  } as SymbolEncodeEntry; // FIXME: remove this when VgEncodeEntry is compatible with SymbolEncodeEntry\n\n  const {markDef, encoding, config} = model;\n  const filled = markDef.filled;\n\n  const opacity = getMaxValue(encoding.opacity) ?? markDef.opacity;\n  const condition = selectedCondition(model, legendCmp, fieldDef);\n\n  if (out.fill) {\n    // for fill legend, we don't want any fill in symbol\n    if (channel === 'fill' || (filled && channel === COLOR)) {\n      delete out.fill;\n    } else {\n      if (out.fill['field']) {\n        // For others, set fill to some opaque value (or nothing if a color is already set)\n        if (legendCmp.get('symbolFillColor')) {\n          delete out.fill;\n        } else {\n          out.fill = {value: config.legend.symbolBaseFillColor ?? 'black'};\n          out.fillOpacity = {value: opacity ?? 1};\n        }\n      } else if (isArray(out.fill)) {\n        const fill =\n          getFirstConditionValue(encoding.fill ?? encoding.color) ?? markDef.fill ?? (filled && markDef.color);\n        if (fill) {\n          out.fill = {value: fill} as ColorValueRef;\n        }\n      }\n    }\n  }\n\n  if (out.stroke) {\n    if (channel === 'stroke' || (!filled && channel === COLOR)) {\n      delete out.stroke;\n    } else {\n      if (out.stroke['field']) {\n        // For others, remove stroke field\n        delete out.stroke;\n      } else if (isArray(out.stroke)) {\n        const stroke = getFirstDefined(\n          getFirstConditionValue(encoding.stroke || encoding.color),\n          markDef.stroke,\n          filled ? markDef.color : undefined\n        );\n        if (stroke) {\n          out.stroke = {value: stroke} as ColorValueRef;\n        }\n      }\n    }\n  }\n\n  if (channel !== OPACITY) {\n    if (condition) {\n      out.opacity = [{test: condition, value: opacity ?? 1}, {value: config.legend.unselectedOpacity}];\n    } else if (opacity) {\n      out.opacity = {value: opacity};\n    }\n  }\n\n  out = {...out, ...symbolsSpec};\n\n  return keys(out).length > 0 ? out : undefined;\n}\n\nexport function gradient(\n  fieldDef: TypedFieldDef<string>,\n  gradientSpec: any,\n  model: UnitModel,\n  channel: ScaleChannel,\n  legendCmp: LegendComponent\n) {\n  if (type(legendCmp, model, channel) !== 'gradient') {\n    return undefined;\n  }\n\n  let out: SymbolEncodeEntry = {};\n\n  const opacity = getMaxValue(model.encoding.opacity) || model.markDef.opacity;\n  if (opacity) {\n    // only apply opacity if it is neither zero or undefined\n    out.opacity = {value: opacity};\n  }\n\n  out = {...out, ...gradientSpec};\n  return keys(out).length > 0 ? out : undefined;\n}\n\nexport function labels(\n  fieldDef: TypedFieldDef<string>,\n  labelsSpec: any,\n  model: UnitModel,\n  channel: NonPositionScaleChannel,\n  legendCmp: LegendComponent\n) {\n  const legend = model.legend(channel);\n  const config = model.config;\n  const condition = selectedCondition(model, legendCmp, fieldDef);\n\n  let out: SymbolEncodeEntry = {};\n\n  if (isTimeFormatFieldDef(fieldDef)) {\n    const isUTCScale = model.getScaleComponent(channel).get('type') === ScaleType.UTC;\n    const expr = timeFormatExpression('datum.value', fieldDef.timeUnit, legend.format, config.timeFormat, isUTCScale);\n    labelsSpec = {\n      ...(expr ? {text: {signal: expr}} : {}),\n      ...labelsSpec\n    };\n  }\n\n  if (condition) {\n    labelsSpec.opacity = [{test: condition, value: 1}, {value: config.legend.unselectedOpacity}];\n  }\n\n  out = {...out, ...labelsSpec};\n\n  return keys(out).length > 0 ? out : undefined;\n}\n\nexport function entries(\n  fieldDef: TypedFieldDef<string>,\n  entriesSpec: any,\n  model: UnitModel,\n  channel: NonPositionScaleChannel,\n  legendCmp: LegendComponent\n) {\n  const selections = legendCmp.get('selections');\n  return selections?.length ? {fill: {value: 'transparent'}} : undefined;\n}\n\nfunction getMaxValue(\n  channelDef:\n    | FieldDefWithCondition<MarkPropFieldDef<string>, number>\n    | ValueDefWithCondition<MarkPropFieldDef<string>, number>\n) {\n  return getConditionValue<number>(channelDef, (v: number, conditionalDef) => Math.max(v, conditionalDef.value as any));\n}\n\nexport function getFirstConditionValue<V extends Value | Gradient>(\n  channelDef: FieldDefWithCondition<MarkPropFieldDef<string>, V> | ValueDefWithCondition<MarkPropFieldDef<string>, V>\n): V {\n  return getConditionValue(channelDef, (v: V, conditionalDef: Conditional<ValueDef<V>>) => {\n    return getFirstDefined<V>(v, conditionalDef.value);\n  });\n}\n\nfunction getConditionValue<V extends Value | Gradient>(\n  channelDef: FieldDefWithCondition<MarkPropFieldDef<string>, V> | ValueDefWithCondition<MarkPropFieldDef<string>, V>,\n  reducer: (val: V, conditionalDef: Conditional<ValueDef<V>>) => V\n): V {\n  if (hasConditionalValueDef(channelDef)) {\n    return (isArray(channelDef.condition) ? channelDef.condition : [channelDef.condition]).reduce(\n      reducer,\n      channelDef.value as any\n    );\n  } else if (isValueDef(channelDef)) {\n    return channelDef.value as any;\n  }\n  return undefined;\n}\n\nfunction selectedCondition(model: UnitModel, legendCmp: LegendComponent, fieldDef: TypedFieldDef<string>) {\n  const selections = legendCmp.get('selections');\n  if (!selections?.length) return undefined;\n\n  const field = stringValue(fieldDef.field);\n  return selections\n    .map(name => {\n      const store = stringValue(varName(name) + STORE);\n      return `(!length(data(${store})) || (${name}[${field}] && indexof(${name}[${field}], datum.value) >= 0))`;\n    })\n    .join(' || ');\n}\n"]}